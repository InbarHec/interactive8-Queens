Morph subclass: #BoardMorph	instanceVariableNames: 'cells queens currentSolution'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13'!!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 19:06'!canPlaceQueenAt: rowIndex column: colIndex    "Check if a queen can be placed at the specified row and column"    | cell |    cell := cells at: rowIndex at: colIndex.    cell isBlocked ifTrue: [^false].     ^queens allSatisfy: [:queen | queen isSafeFrom: rowIndex column: colIndex].! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 1/25/2025 23:13'!displaySolution: solution	"Display a solution on the board"	solution do: [:rowIndex |		| colIndex |		colIndex := solution at: rowIndex.		self placeQueenAt: rowIndex column: colIndex.		(Delay forSeconds: 1) wait.		self removeQueenAt: rowIndex column: colIndex.	].! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 16:01'!drawConflictLineFrom: fromCell to: toCell    "Draw a red line between two conflicting queens"    | line startPoint endPoint |    startPoint := fromCell center.    endPoint := toCell center.    line := LineMorph new.    line borderWidth: 2.    line color: Color blue.    line setVertices: {startPoint. endPoint}.        World addMorph: line.    (World doOneCycle).      (Delay forMilliseconds: 500) wait.      line delete.    (World doOneCycle).! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 21:52'!findFirstSolution	"Find the first solution"	queens isNil ifTrue: [queens := OrderedCollection new].	queens isEmpty ifTrue: [^self recursiveSolveFromRow: 1 col:1].! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 21:52'!findNextSolution	"Find the next solution"	^self recursiveSolveFromRow: 1 col:1.! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 18:13'!initialize    "Create an 8x8 board and initialize the layout"    | currentCell |    super initialize.    self bounds: (0 @ 0 extent: 400 @ 400).    self layoutPolicy: TableLayout new.    self listDirection: #topToBottom.    self color: Color black.    cells := Matrix new: 8.     queens := OrderedCollection new.    1 to: 8 do: [:row |        | rowContainer |        rowContainer := Morph new layoutPolicy: TableLayout new.        rowContainer listDirection: #leftToRight.	  rowContainer extent: 400@50.	  rowContainer handlesMouseDown: false.        1 to: 8 do: [:col |            currentCell := CellMorph new row: row column: col.            cells at: row at: col put: currentCell. 		currentCell handlesMouseDown: true.            rowContainer addMorph: currentCell.        ].        self addMorph: rowContainer.    ].! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 13:13'!placeQueenAt: rowIndex column: colIndex	"Place a queen at the specified row and column"	| cell |	(cell := cells at: rowIndex at: colIndex) placeQueen.	queens add: cell.! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 22:10'!recursiveSolveFromRow: rowIndex col: colIndex    "Recursively solve the problem row by row, skipping blocked cells while ensuring left-to-right placement."    | cell conflict |    (rowIndex > 8) ifTrue: [        currentSolution := queens collect: [:q | q row].        ^ true.    ].    (colIndex > 8) ifTrue: [^false].      cell := cells at: rowIndex at: colIndex.    cell isBlocked ifTrue: [        ^ self recursiveSolveFromRow: rowIndex col: colIndex + 1.    ].    cell highlight.    conflict := nil.    queens do: [:queen |        (queen isSafeFrom: rowIndex column: colIndex) ifFalse: [            conflict := queen.        ].    ].    conflict ifNotNil: [         self drawConflictLineFrom: conflict to: cell.        cell unhighlight.    ].    (self canPlaceQueenAt: rowIndex column: colIndex) ifTrue: [        self placeQueenAt: rowIndex column: colIndex.        (World doOneCycle).          (Delay forMilliseconds: 500) wait.          (self recursiveSolveFromRow: rowIndex + 1 col: 1) ifTrue: [^true].        self removeQueenAt: rowIndex column: colIndex.    ].    cell unhighlight.    (World doOneCycle).    (Delay forMilliseconds: 500) wait.    ^ self recursiveSolveFromRow: rowIndex col: colIndex + 1.! !!BoardMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 13:13'!removeQueenAt: rowIndex column: colIndex	"Remove the queen at the specified row and column"	| cell |	(cell := cells at: rowIndex at: colIndex) removeQueen.	queens remove: cell.! !SimpleSwitchMorph subclass: #CellMorph	instanceVariableNames: 'row col isOccupied isBlocked queenMorph blockMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13'!!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 13:59'!col	^col! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 11:39'!handleMouseUp: anEvent	^true! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 15:03'!highlight    "Highlight this cell to show an attempted queen placement"    self borderWidth: 2.    self borderColor: Color black.    (World doOneCycle). ! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 18:57'!initialize	"Initialize the cell"	super initialize.	self label: ' '.	self extent: 50 @ 50.	self borderWidth: 1.	isBlocked := false.	isOccupied := false.	self handlesMouseDown: true.	self on: #mouseDown send: #mouseDown: to: self.	self on: #mouseUp send: #mouseUp: to: self.	! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 12:56'!isBlocked	^isBlocked! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 1/25/2025 23:15'!isSafeFrom: aRow column: aCol	"Check if this cell is safe from attack by another queen"	(row = aRow or: [col = aCol] or: [(row - aRow) abs = (col - aCol) abs]) ifTrue: [^false].	^true.! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 21:29'!mouseDown: aMouseEvent    aMouseEvent yellowButtonPressed         ifTrue: [		self toggleBlock.		aMouseEvent hand releaseMouseFocus.		].	self changed.! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 21:28'!mouseUp: aMouseEvent    aMouseEvent yellowButtonPressed 	ifTrue: [^true].! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 21:10'!placeQueen    "Place a queen using an image"    isOccupied ifFalse: [	isBlocked ifFalse:[        queenMorph := (ImageMorph new newForm: ((ImageReadWriter formFromFileNamed: 'queen.png') magnifyBy:0.1)).        queenMorph position: self center - (queenMorph extent // 2).                self addMorph: queenMorph.        isOccupied := true.    ].].! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 1/25/2025 23:14'!removeQueen	"Remove the queen from this cell"	isOccupied ifTrue: [		self removeMorph: queenMorph.		queenMorph := nil.		isOccupied := false.	].! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 13:58'!row	^row! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 1/27/2025 11:35'!row: aRow column: aCol	"Set the row and column for the cell"	row := aRow.	col := aCol.	(col + row) even		ifTrue: [self color: Color white]		ifFalse: [self color: Color lightGray].! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 22:33'!toggleBlock	isBlocked := isBlocked not.	self color: (isBlocked 				  ifTrue:[Color lightRed]				  ifFalse: [(col + row) even							ifTrue: [Color white]							ifFalse: [Color lightGray]]				).		(World doOneCycle).! !!CellMorph methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 15:03'!unhighlight    "Remove the highlight from this cell"    self borderWidth: 1.    self borderColor: Color transparent.    (World doOneCycle).! !Object subclass: #Interactive8Queens	instanceVariableNames: 'board'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman13'!!Interactive8Queens methodsFor: 'as yet unclassified' stamp: 'IH 1/25/2025 18:22'!initialize	"Initialize the 8-queens interactive board"	board := BoardMorph new.	board openInWorld.! !!Interactive8Queens methodsFor: 'as yet unclassified' stamp: 'IH 2/3/2025 22:37'!solve	"Solve the 8-queens problem and display solutions dynamically"	| count noSolution endSolution |	Transcript clear.	(board findFirstSolution) ifTrue: [		count := 1.		[true] whileTrue: [			Transcript show: 'Solution ', count printString, ': ', board currentSolution printString; cr.			board displaySolution: board currentSolution.			 (Delay forSeconds: 2) wait.			count := count + 1.			(board findNextSolution) ifFalse: [				endSolution := StringMorph new contents: 'End of Solution!!'.				endSolution emphasis: 1; color: Color blue; borderColor: Color black; center: board center; 		openInWorld.		board addMorph: endSolution.				].		].	] ifFalse: [		noSolution := StringMorph new contents: 'No Solution!!'.		noSolution emphasis: 1; color: Color red; borderColor: Color black; center: board center; 		openInWorld.		board addMorph: noSolution.	].! !